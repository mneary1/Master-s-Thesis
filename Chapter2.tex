%!TEX root = mainthesis.tex

\renewcommand{\thechapter}{2}

\chapter{Background}
The purpose of this chapter is to describe the components of Intelligent Tutoring Systems (ITS), and to give motivation for using ITS in programming courses. This chapter provides the necessary background knowledge on ITS, first-order logic, abstract syntax trees, and graph theory in order to understand the methodology in Chapter 4.

\section{Intelligent Tutoring}

An Intelligent Tutoring System (ITS) provides students with one-on-one guided instruction in a particular subject, typically after they have had prior exposure to that subject in a traditional classroom setting. A typical ITS mimics the interaction between a human tutor and a student. The goal of this interaction is to bring the student from a state of confusion in a subject to mastery of that subject. The ITS develops an internal model of what the student understands, providing the student with feedback based on that model to help guide the student towards mastery. The successful implementation of a tutoring system can be rewarding for both student and teacher, relieving some of the burden of teaching and learning in particularly difficult courses.

A majority of the content in introductory programming courses is difficult to grasp for the novice student, especially considering that the material is almost entirely novel. Those who fall behind in an introductory course are likely to suffer learned helplessness because each new concept builds upon previous concepts \cite{Jenkins2002}. Students also find it difficult to combine the basic structures of programming to form solutions to larger problems. If a student is able to think of a programmatic solution, they may still have trouble fixing bugs within that solution \cite{Lahtinen2005}. Students learn different concepts at different rates, which makes deciding what programming concepts to teach in what sequence particularly hard \cite{Rivers2016}. The programming instructor must find solutions for each these problems in order to be effective. The difficulty of programming for first-time learners and their instructors justifies the application of ITS to introductory programming.

An Intelligent Programming Tutor (IPT) is a specific implementation of an ITS for introductory programming. There are three important components of an IPT: domain knowledge, student knowledge, and tutoring knowledge. An IPT needs \emph{domain knowledge}, or a method of representing concepts related to programming (e.g., language syntax), in order to identify define content mastery. It needs a model of \emph{student knowledge}, or a method of encoding student understanding based on observation (e.g., code samples, multiple choice answers). An IPT also needs to know \emph{how to tutor}, or how to provide meaningful feedback to a student in a timely manner. Exceptional IPTs must have all three components, as constructive feedback is best generated from the combination of an accurate student model and sound domain knowledge. In this chapter, we discuss methods of modeling domain and student knowledge. The next chapter focuses on constructive feedback in-depth.

\subsection{Domain Knowledge}

It is imperative that an ITS has expert-level domain knowledge in the subject area it is applied to. An IPT needs knowledge of programming concepts in order to model what a student knows and to give feedback to that student. The necessary programming concepts for an IPT are how to write programs, how to identify and describe errors, and declarative information about programming structures \cite{Pillay2003}. These concepts should be encoded in an easily accessible manner, such that the student model and feedback generator can leverage the information. Programming domain knowledge need not be a separate entity in an IPT, although there are methods that rely on domain knowledge as a separate entity. One can easily incorporate domain knowledge into a student model or feedback generation method.

One direct method of domain knowledge representation utilizes first-order logic to create a knowledge base of programming concepts. This method views a solved programming problem as a conjunction of predicates that describe the expected constructs in an ideal solution. Weregama and Reye
\cite{Weragama2014} translated a set of student code examples into a knowledge base of correct solutions. They leverage this method of domain knowledge encoding to administer tutoring through simple planning algorithms. This method creates an accurate tutoring system, and is suited for handling the differences in solutions to problems.

Some IPTs encode domain knowledge as a graph to capture the relationship between programming concepts. Understanding the relationship among programming concepts is crucial for navigating the tutoring process in an IPT. If the system understands what the student has not yet mastered, and it knows the similar concepts that they do understand, it can generate feedback to bridge that gap. Kumar extends the graph of programming concepts, adding learning objectives to each concept \cite{Kumar2014}. Expert domain knowledge is the foundation of feedback generation and the internal student model.

\subsection{Student Knowledge}

It is important for the interaction between an intelligent tutor and a human to be as personalized as possible, since such a system must have an understanding of what the current user is capable of. It should reason from what it observes of the student's actions to determine the content that student has learned. This is a difficult task due to the inherent uncertainty in the observation of a student. A variety of methods for the representation of student knowledge that handle this uncertainty currently exist. A few of these methods utilize classic techniques such as Bayesian networks and Markov Decision Processes, while others employ novel methods. I first discuss the classic techniques applied to this problem, then more recent methods.

\todo{A variety of methods for the representation of student knowledge that handle this uncertainty currently exist}

\todo{give citations}
A Bayesian network is a directed acyclic graph used to encode conditional dependencies among random variables. These networks are the most utilized method for the modeling of student knowledge because they are easy to implement and they can determine the probability that some concept is understood given evidence, or lack thereof, for that hypothesis. Butz et al. use a Bayesian network to model the student who is using the system, and update their model based on the student's self-assessed understanding \cite{Butz2004}. Chang et al. go a step further by treating the student modeling problem as a function of time. This approach allows for the application of a dynamic Bayesian network. The model constructed is better than standard knowledge tracing, at the cost of an increase in training time \cite{Chang2006}.
%todo cite MDPs
A Markov Decision Process can also be used as a model for student behavior in a tutoring system. This technique determines an optimal policy for the intelligent tutor given a set of actions it can take (feedback to the student) and the states that result from taking those actions (student understanding of the material), with some probability that action A results in a transition from state S to S$'$. A student can be modeled using a Partially Observable Markov Decision Process (POMDP) because there is a level of uncertainty in the result of an action taken by a student. The model must do what it can with unreliable evidence, since a piece of feedback the student receives may either help or hurt their understanding of the topic. A student's response to a problem can vary, and it is not certain what state of understanding they are in until after their response is analyzed. A POMDP is a powerful modeling method, but the application of POMDPs can be intractable. Folsom-Kovarik et al. propose two variations---state queues and observation chains---of POMDPs to solve the problem of increased complexity in modeling student knowledge \cite{Folsom-Kovarik2013}. Both methods use properties of tutoring tasks to compress the information needed to reliably model a student with a POMDP. Their results show that their compression methods do not have any negative effect on the student model, but there was no substantial improvement over existing modeling methods.

% todo: *really* should clear up the last sentence or two: why is it there?
% todo: is the conclusion that this provides an efficiency boost but doesn't help (nor hurt) predictive performance?

%TODO: add a show section on hint generation?


\section{First-Order Logic}

My thesis uses the concept of first-order logic (FOL) to represent a particular kind of dependency among lines of code.  First-order logic statements utilize variables in order to describe objects and relationships in the world. These variables can be quantified: that is, one can write a statement that applies to every object or at least one object without naming anything specifically. A term in an FOL statement can be a constant, a variable, or a function. A constant is a symbol that represents a specific thing in the world. A variable can represent any object in the world. A function is a rule applied to one or more terms. Terms are used to write sentences, a predicate of n terms that evaluates to some truth, in FOL.

Complex sentences are created by joining terms with logical connectors, including conjunction ($\land$), disjunction ($\lor$), or implication ($\rightarrow$). Sentences can be quantified either universally ($\forall$, ``for all") or existentially ($\exists$, ``there exists"). The universal quantifier applied to a variable in a sentence is an assertion that the sentence is satisfiable by all members of the variable's domain. The existential quantifier on the same variable and sentence is an assertion that the sentence is satisfied by at least one member of its domain. As an example, consider the following English sentence: \emph{``All graduate students are tired.''} This is a blanket statement about all graduate students; therefore, a universally quantified sentence is necessary. The translation of this English sentence in FOL could look like this: $\forall x \ GradStudent(x) \Rightarrow \ Tired(x)$. In this sentence, the variable $x$ has the domain of people. This sentence is read as, ``For all people, if that person is a graduate student then they are tired.'' A group of sentences can be written to describe a system, and subsequently reasoned over to prove different sentences related to that system.

%\emph{``Anyone who has graduated and has a job is happy.''} This is a complex statement that applies to anyone, so an existential quantifier is necessary. Taking x to have the domain of all people again, in FOL this statement is: $\exists x \ Graduated(x) \land hasJob(x) \Rightarrow happy(x)$. This is read as ``There exists some person who if they have graduated and have a job then they are happy.''

FOL is used to prove statements about the world based on what is already known or observable. Observed facts and known rules can be combined into a collection of sentences known as a knowledge base (KB). The KB is a collection of statements about the world. A model of a KB is an assignment of True/False values to each symbol in the KB. Given a model, the conjunction of each evaluated sentence under that model results in an over all KB evaluation to True or False. KB evaluation is important to determining logical entailment.

The logical entailment of a sentence S by a KB, denoted by $KB \models S$, occurs when every model that evaluates KB to True also evaluates S to be True. That is to say that the sentence S is a logical consequence of the knowledge base. Resolution is used to check if $KB \models S$. This process attempts to prove that no model exists such that $KB \land \lnot S$ evaluates to True. Resolution is performed by applying logical inference rules to the previous conjunction. If a contradiction arises during the application of logical inference then that proves $KB \models S$.

%TODO: MUST EXPLAIN **WHY** FOL IS NECESSARY!!!!!

\section{Graphs}
A graph, sometimes referred to as a network, is a mathematical construct used to describe a relationship among objects. A graph G is comprised of two sets (V, E), which correspond to vertices and edges. Each vertice, or node, represents one particular object. Each edge is a pair of vertices (u, v) that represents a connection between two objects. The edges of a directed graph go one way from the source node (u) to the destination node (v), whereas an undirected graph's edges are bidirectional. A relevant problem to this thesis is that of shortest paths.

A number of relationships exist within a computer program, where single instructions interact with data or with other instructions to accomplish a particular goal. A program can be represented as a graph where nodes correspond to line numbers of individual instructions and edges correspond to an interaction that takes place between two instructions.

\subsection{Single Source Shortest Path}
Given a directed graph G = (V, E), a path from a starting node to a destination node is a sequence of nodes in V such that each pair of adjacent nodes in the sequence are connected by an edge in E. The problem of shortest paths (SSSP) is finding the path of minimal length from a starting node to a goal node. The problem of single source shortest paths is finding every shortest path from some beginning node to every other node in the graph.

%TODO: MUST EXPLAIN **WHY** SSSP IS RELEVATNT TO MY THESIS
%TODO: algorithm description and/or graph example figure here

\section{Abstract Syntax Trees}
Formal representation of language syntax and structure is useful at compile time and for general analysis of program structure. An abstract syntax tree (AST) encodes the syntactical structure of source code as a tree; i.e., an undirected graph where any pair of vertices have exactly one path that connects them. Each node of an AST represents an abstract programming construct within the source, such as statements, expressions, or decisions. An AST disregards portions of the actual syntax since some constructs, like grouping of parentheses, can be derived from the tree structure itself.

%TODO: MUST EXPLAIN **WHY** ASTs ARE RELEVANT TO MY THESIS
%TODO: AST example figure here
